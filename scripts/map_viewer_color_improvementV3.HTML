<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapbox GeoJSON Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 1;
            max-width: 300px;
            font-family: sans-serif;
            max-height: 90vh;
            overflow-y: auto;
        }
        .file-input {
            display: none;
        }
        .file-upload-btn {
            display: inline-block;
            padding: 8px 12px;
            background: #3887be;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .additional-file-upload-btn {
            display: inline-block;
            padding: 8px 12px;
            background: #38be7d;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .layer-control {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .color-picker {
            margin-left: 10px;
            width: 20px;
            height: 20px;
            padding: 0;
            border: none;
        }
        .mapboxgl-popup-content {
            padding: 15px;
        }
        .instructions {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        /* Ensure the cursor changes appropriately */
        .mapboxgl-canvas-container.mapboxgl-interactive {
            cursor: grab;
        }
        .mapboxgl-canvas-container.mapboxgl-interactive:active {
            cursor: grabbing;
        }
        /* Add specific style for points */
        .point-hover {
            cursor: pointer !important;
        }
        /* Filtering section styles */
        .filter-section {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .filter-section input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            box-sizing: border-box;
        }
        .filter-section button {
            margin-top: 5px;
            padding: 5px 10px;
            background: #3887be;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .filter-section button:hover {
            background: #2b6b99;
        }
        /* Legend styles */
        .legend {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 50%;
        }
        /* Additional layers section styles */
        .additional-layers {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .additional-layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        /* Line segment legend styles */
        .segment-legend {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            display: none;
        }
        .segment-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .segment-color {
            width: 30px;
            height: 5px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="control-panel">
        <h3>Chinatown Curb Map</h3>
        <label class="file-upload-btn" for="primary-file-input">
            Upload Primary GeoJSON
        </label>
        <input type="file" id="primary-file-input" class="file-input" accept=".geojson,.json">
        
        <label class="additional-file-upload-btn" for="additional-file-input">
            Upload Additional GeoJSON
        </label>
        <input type="file" id="additional-file-input" class="file-input" accept=".geojson,.json">
        
        <div id="file-info"></div>
        
        <!-- Legend Section with Toggle Functionality -->
        <div class="legend" id="legend" style="display: none;">
            <h4>Sign Types</h4>
            <div id="legend-items"></div>
        </div>
        
        <!-- Line Segment Legend Section -->
        <div class="segment-legend" id="segment-legend" style="display: none;">
            <h4>Line Segment Legend</h4>
            <div id="segment-legend-items"></div>
        </div>
        
        <!-- Primary Layer Controls -->
        <div id="layer-controls"></div>
        
        <!-- About this dataset -->
        <div class="additional-layers" id="additional-layers">
            <h4>About this data set</h4>
            <h5> This map is a first iteration of the a future map of all Chinatown Curb Regulations.  Line segments represent distances betwen signposts, fire hydrants, parking meters and curb cuts.  These line segments will be used to calculate curb capacity in the future. 

            Click around on individual parking signs to see what data the city has stored in Cartegraph! We will be enriching this data in Q2. <h5>

            <div id="additional-layer-items"></div>
        </div>
        
        <div class="stats">
            <p>Features: <span id="feature-count">0</span></p>
            <p>Visible: <span id="visible-count">0</span></p>
            <p>Loaded in: <span id="load-time">N/A</span></p>
            <p>Status: <span id="status-info">N/A</span></p>
        </div>
        
        <div class="instructions">
            <p><small>Click on any sign to view details. Toggle sign types in the legend.</small></p>
        </div>
    </div>

    <script>
        // Replace with your Mapbox access token
        mapboxgl.accessToken = 'pk.eyJ1IjoiYm9zdG9uc2FtNjE3IiwiYSI6ImNtODNlbnBoNzFvaTcyd3FienphaXRma2oifQ.S8oVyPkHgza9vrUBu0nwjQ';
        
        // Initialize the map
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/light-v11',
            center: [-96, 37.8], // Center on US
            zoom: 3,
            cursor: 'grab' // Set default cursor to grab
        });
        
        // Track loaded datasets
        const datasets = [];
        
        // Track additional datasets
        const additionalDatasets = [];
        
        // Track current popup globally
        let currentPopup = null;
        
        // Track sign prefixes and their colors
        let signTypeColors = {};
        
        // At the global scope (outside any function)
        let signDataGlobal = null;

        const segmentColors = [
            '#e41a1c', // Red
            '#377eb8', // Blue
            '#4daf4a', // Green
            '#984ea3', // Purple
            '#ff7f00', // Orange
            '#ffff33', // Yellow
            '#a65628', // Brown
            '#f781bf', // Pink
            '#999999', // Gray
            '#66c2a5', // Teal
            '#fc8d62', // Salmon
            '#8da0cb', // Light blue
            '#e78ac3', // Light pink
            '#a6d854', // Light green
            '#ffd92f', // Light yellow
            '#e5c494'  // Tan
        ];
        
        // Track line segment colors
        let lineSegmentColors = {};
        
        // Function to find nearest sign to a point
        function findNearestSign(point, signFeatures) {
            let nearestSign = null;
            let minDistance = Infinity;
            
            signFeatures.forEach(sign => {
                // Make sure we're dealing with a point feature
                if (sign.geometry.type !== 'Point') return;
                
                const signPoint = sign.geometry.coordinates;
                const distance = calculateDistance(point, signPoint);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestSign = sign;
                }
            });
            
            // Return the nearest sign, or the first sign as fallback
            return nearestSign || signFeatures[0];
        }

        // Calculate distance between two points (simple Euclidean for projected coordinates)
        function calculateDistance(point1, point2) {
            const dx = point2[0] - point1[0];
            const dy = point2[1] - point1[1];
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Function to adjust color opacity
        function adjustColorOpacity(hexColor, opacity) {
            // Handle if the color is already in rgba format
            if (hexColor.startsWith('rgba') || hexColor.startsWith('rgb')) {
                // Parse existing rgba/rgb color and modify opacity
                const rgbMatch = hexColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
                if (rgbMatch) {
                    return `rgba(${rgbMatch[1]}, ${rgbMatch[2]}, ${rgbMatch[3]}, ${opacity})`;
                }
                return hexColor; // Return original if parsing fails
            }
            
            // Handle hex color format
            if (!hexColor || !hexColor.startsWith('#')) {
                return `rgba(78, 121, 167, ${opacity})`; // Default color if invalid
            }
            
            // Convert hex to RGB
            const r = parseInt(hexColor.slice(1, 3), 16) || 0;
            const g = parseInt(hexColor.slice(3, 5), 16) || 0;
            const b = parseInt(hexColor.slice(5, 7), 16) || 0;
            
            // Return rgba format
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        // Function to map regulation types to colors (if not already defined in sign properties)
        function getColorForRegulationType(regulationType) {
            // Create a mapping of regulation types to your professional colors
            const regulationColorMap = {
                '2 Hour Parking': '#e15759',
                'No Stopping': '#f28e2c',
                'Other': '#4e79a7',
                'ParkBoston/Metered': '#af7aa1',
                'Resident Parking': '#76b7b2',
                'Street Cleaning': '#ff9da7',
                'Tow Zone': '#9c755f',
                'Tow Zone: Street Cleaning/Snow Emergency': '#e7ba52',
                'nan': '#bab0ab'
                // Add more mappings as needed
            };

            return regulationColorMap[regulationType] || '#4e79a7'; // Return the color or default
        }

        //Clean invisible characters from data
        function cleanControlCharacters(geojsonData) {
          // Make a deep copy to avoid modifying the original
          const cleanedData = JSON.parse(JSON.stringify(geojsonData));
          
          // Process each feature
          cleanedData.features.forEach(feature => {
            if (feature.properties) {
              // Clean regulation_type if it exists
              if (feature.properties.regulation_type) {
                feature.properties.regulation_type = 
                  feature.properties.regulation_type.replace(/[\u0000-\u001F]/g, '');
              }
              
              // Clean mutcd_description if it exists
              if (feature.properties.mutcd_description) {
                feature.properties.mutcd_description = 
                  feature.properties.mutcd_description.replace(/[\u0000-\u001F]/g, '');
              }
            }
          });
          
          return cleanedData;
        }

        function load_sign_Dataset() {
            // Show loading status
            document.getElementById('status-info').textContent = 'Loading default dataset...';
            
            // Path to your GeoJSON file
            // For local testing:
            const dataUrl = './data/regulations_categorized.geojson';
            // For GitHub deployment later:
            // const dataUrl = 'https://raw.githubusercontent.com/yourusername/yourrepo/main/your-data.geojson';
            
            // Fetch the GeoJSON file
            fetch(dataUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.status}`);
                    }
                    return response.json();
                })
                .then(geojson => {
                   // Clean the GeoJSON data before using it
                    const cleanedGeojson = cleanControlCharacters(geojson);
                    
                    // Inspect the cleaned data values
                    console.log("--- INSPECTING CLEANED DATA VALUES ---");
                    
                    // Check if there are any features
                    console.log("Number of features:", cleanedGeojson.features.length);
                    
                    // Look at the first few features to see their regulation_type values
                    console.log("Sample of regulation_type values:");
                    for (let i = 0; i < Math.min(5, cleanedGeojson.features.length); i++) {
                        const feature = cleanedGeojson.features[i];
                        if (feature.properties) {
                            console.log(`Feature ${i}:`);
                            console.log(`  regulation_type: "${feature.properties.regulation_type}"`);
                            console.log(`  Length: ${feature.properties.regulation_type?.length || 0}`);
                            console.log(`  mutcd_description: "${feature.properties.mutcd_description}"`);
                        }
                    }
    
                    // Check for any very short regulation_type values
                    const shortValues = cleanedGeojson.features
                        .filter(f => f.properties?.regulation_type?.length <= 2)
                        .map(f => f.properties.regulation_type);
                    
                    if (shortValues.length > 0) {
                        console.log("Found regulation_type values with 2 or fewer characters:", shortValues);
                    }
                    
                    // Add the cleaned dataset to the map
                    addDatasetToMap(cleanedGeojson, 'Default Dataset');
                    document.getElementById('status-info').textContent = 'Default dataset loaded successfully';
                })
                .catch(error => {
                    console.error('Error loading default dataset:', error);
                    document.getElementById('status-info').textContent = `Error loading dataset: ${error.message}`;
                });
        }

        function load_curbzone_Dataset() {
            // Show loading status
            document.getElementById('status-info').textContent = 'Loading default dataset...';
            
            // Path to your GeoJSON file
            // For local testing:
            const dataUrl = './data/labeled_curbs.geojson';
            // For GitHub deployment later:
            // const dataUrl = 'https://raw.githubusercontent.com/yourusername/yourrepo/main/your-data.geojson';
            
            // Fetch the GeoJSON file
            fetch(dataUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.status}`);
                    }
                    return response.json();
                })
                .then(geojson => {
                    // Add the dataset to the map (reusing existing function)
                    addAdditionalDatasetToMap(geojson, 'Default Dataset');
                    document.getElementById('status-info').textContent = 'curb zone dataset loaded successfully';
                })
                .catch(error => {
                    console.error('Error loading default dataset:', error);
                    document.getElementById('status-info').textContent = `Error loading dataset: ${error.message}`;
                });
        }
        
        // Initialize event listeners after map loads
        map.on('load', function() {
            // Set default cursor
            map.getCanvas().style.cursor = 'grab';
            
            // Update cursor when panning starts/ends
            map.on('mousedown', function() {
                map.getCanvas().style.cursor = 'grabbing';
            });
            
            map.on('mouseup', function() {
                map.getCanvas().style.cursor = 'grab';
            });

            // Load the default dataset once the map is ready
            load_sign_Dataset();

            // Load the curb zone dataset once map is ready
            load_curbzone_Dataset();


        });
        
        // Check and fix geojson if needed (convert coordinates to WGS84)
        function checkAndFixGeojson(geojson) {
            // Check if it's already in the right format
            if (!geojson.features || geojson.features.length === 0) return geojson;
            
            // Check first feature to see if it has lat/long properties
            const firstFeature = geojson.features[0];
            const hasLatLongProps = 'latitude' in firstFeature.properties && 'longitude' in firstFeature.properties;
            
            // Check if coordinates look like they might be in a projected system (not WGS84)
            const coords = firstFeature.geometry.coordinates;
            const isProjected = Array.isArray(coords) && 
                               ((coords.length === 2 && (Math.abs(coords[0]) > 180 || Math.abs(coords[1]) > 90)) ||
                                (coords.length === 3 && (Math.abs(coords[0]) > 180 || Math.abs(coords[1]) > 90)));
            
            // If the coordinates are projected and we have lat/long props, fix the coordinates
            if (isProjected && hasLatLongProps) {
                console.log("Fixing GeoJSON coordinates - converting from projected to WGS84");
                
                const fixedGeojson = {
                    type: "FeatureCollection",
                    features: geojson.features.map(feature => {
                        // Create a new feature with the same properties
                        const newFeature = {
                            type: "Feature",
                            properties: feature.properties,
                            geometry: {
                                type: "Point",
                                // Use the longitude and latitude properties for coordinates
                                coordinates: [
                                    parseFloat(feature.properties.longitude), 
                                    parseFloat(feature.properties.latitude)
                                ]
                            }
                        };
                        return newFeature;
                    })
                };
                return fixedGeojson;
            }
            
            return geojson;
        }
        
        function getSignPrefix(code) {
            if (!code) return null;
            // Just return the full code instead of extracting a prefix
            return code;
        }
        
        // Get sign prefix from mutcd_code_field (in JavaScript, not in MapboxGL expression)
        //function getSignPrefix(code) {
            //if (!code) return null;



            // Find the position of the dash
            //const dashIndex = code.indexOf('-');

            // If there's a dash, return everything before it
            //if (dashIndex !== -1) {
                //return code.substring(0, dashIndex);
            //}

            // If no dash, return first 1-2 characters (letters)
            //const match = code.match(/^[A-Za-z]{1,2}/);
            //return match ? match[0] : null;
        //}
        


        // Generate consistent color for a sign prefix
        function getColorForSignType(prefix) {
            if (!prefix) return '#cccccc'; // Default gray
            
            // If we've already assigned a color, use it
            if (signTypeColors[prefix]) {
                return signTypeColors[prefix];
            }
            
            // Otherwise, generate a color based on the prefix
            const prefixSum = prefix.split('').reduce((sum, char) => sum + char.charCodeAt(0), 0);
            const hue = (prefixSum * 137.5) % 360; // Generate a hue based on the characters
            const saturation = 70; // Fixed saturation for better visibility
            const lightness = 45; // Fixed lightness for better visibility
            
            // Create HSL color
            const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            
            // Store for future reference
            signTypeColors[prefix] = color;
            
            return color;
        }
        
            // Pre-process features to assign colors based on regulation types
            function processSignColors(features) {
                // Clear existing sign colors
                signTypeColors = {};
                
                // Process each feature
                features.forEach(feature => {
                    if (feature.properties && feature.properties.regulation_type) {
                        const regulationType = feature.properties.regulation_type;
                        if (regulationType) {
                            // Still extract the prefix for other functionality
                            const prefix = getSignPrefix(regulationType);
                            if (prefix) {
                                // Store the prefix for compatibility
                                feature.properties.signPrefix = prefix;
                            }
                            
                            // Store the color mapping based on full regulation type
                            const color = getColorForRegulationType(regulationType);
                            if (color) {
                                signTypeColors[regulationType] = color;
                            }
                        }
                    }
                });

                return signTypeColors;
            }
        
        // Update the legend with sign prefixes and colors with toggle functionality
        function updateLegend() {
            const legendContainer = document.getElementById('legend-items');
            if (!legendContainer) return; // Safety check
            
            legendContainer.innerHTML = '';
            
            // Show the legend section
            const legendSection = document.getElementById('legend');
            if (legendSection) {
                legendSection.style.display = 'block';
            }
            
            // Sort prefixes alphabetically
            const sortedPrefixes = Object.keys(signTypeColors).sort();
            
            // Initialize active prefixes (all active by default)
            if (!window.activePrefixes) {
                window.activePrefixes = new Set();
            }
            
            // Add all prefixes to active set by default
            sortedPrefixes.forEach(prefix => {
                window.activePrefixes.add(prefix);
            });
            
            // Add each prefix to the legend with a checkbox
            sortedPrefixes.forEach(prefix => {
                const color = signTypeColors[prefix];
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                // Create checkbox for toggling this sign type
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = window.activePrefixes.has(prefix);
                checkbox.style.marginRight = '5px';
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        window.activePrefixes.add(prefix);
                    } else {
                        window.activePrefixes.delete(prefix);
                    }
                    
                    // Apply the filter to show/hide sign types
                    applySignTypeFilter();
                });
                
                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'legend-color';
                colorSwatch.style.backgroundColor = color;
                
                const prefixLabel = document.createElement('span');
                prefixLabel.textContent = `${prefix}`;
                
                legendItem.appendChild(checkbox);
                legendItem.appendChild(colorSwatch);
                legendItem.appendChild(prefixLabel);
                legendContainer.appendChild(legendItem);
            });
        }
        
        // Update line segment legend
        function updateLineSegmentLegend(dataset) {
            const legendContainer = document.getElementById('segment-legend-items');
            if (!legendContainer) return; // Safety check
            
            legendContainer.innerHTML = '';
            
            // Show the legend section
            const legendSection = document.getElementById('segment-legend');
            if (legendSection) {
                legendSection.style.display = 'block';
            }
            
            // Add each segment to the legend
            Object.keys(dataset.segmentColors).forEach((segmentId, index) => {
                const color = dataset.segmentColors[segmentId];
                const legendItem = document.createElement('div');
                legendItem.className = 'segment-legend-item';
                
                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'segment-color';
                colorSwatch.style.backgroundColor = color;
                
                const segmentLabel = document.createElement('span');
                // Use properties.name if available, otherwise use "Segment #"
                const feature = dataset.originalData.features.find(f => f.id === segmentId);
                const segmentName = feature && feature.properties.name ? 
                    feature.properties.name : 
                    `Segment ${index + 1}`;
                    
                segmentLabel.textContent = segmentName;
                
                legendItem.appendChild(colorSwatch);
                legendItem.appendChild(segmentLabel);
                legendContainer.appendChild(legendItem);
            });
        }
        
        function applySignTypeFilter() {
            // Only apply to primary dataset with point geometry
            datasets.forEach(dataset => {
                if (!dataset.originalData || !dataset.originalData.features) return;
                
                // Create a filtered copy of the dataset
                const filteredData = {
                    type: 'FeatureCollection',
                    features: dataset.originalData.features.filter(feature => {
                        // If feature has a mutcd_code_field property
                        if (feature.properties.regulation_type) {
                            const prefix = getSignPrefix(feature.properties.regulation_type);
                            // Keep only if prefix is in the active set
                            return window.activePrefixes.has(prefix);
                        }
                        // Keep features without a prefix
                        return true;
                    }).map(feature => {
                        // Create a copy of the feature to avoid modifying the original
                        const featureCopy = JSON.parse(JSON.stringify(feature));
                        
                        // Make sure signColor property is set based on the sign prefix
                        if (featureCopy.properties.regulation_type) {
                            const prefix = getSignPrefix(featureCopy.properties.regulation_type);
                            featureCopy.properties.signColor = getColorForSignType(prefix);
                            featureCopy.properties.signPrefix = prefix;
                        }
                        
                        return featureCopy;
                    })
                };
                
                // Update the map source with filtered data
                if (map.getSource(dataset.sourceId)) {
                    map.getSource(dataset.sourceId).setData(filteredData);
                }
                
                // Update visible feature count
                document.getElementById('visible-count').textContent = filteredData.features.length;
            });
        }
        
        function getBounds(geojson) {
            if (!geojson.features || geojson.features.length === 0) {
                return null;
            }
            
            // Initialize with the coordinates of the first point
            let west = 180, south = 90, east = -180, north = -90;
            
            // Iterate through all features to find the bounding box
            geojson.features.forEach(feature => {
                if (feature.geometry) {
                    // Process different geometry types
                    if (feature.geometry.type === 'Point') {
                        const [lng, lat] = feature.geometry.coordinates;
                        west = Math.min(west, lng);
                        south = Math.min(south, lat);
                        east = Math.max(east, lng);
                        north = Math.max(north, lat);
                    } else if (feature.geometry.type === 'LineString') {
                        feature.geometry.coordinates.forEach(coord => {
                            const [lng, lat] = coord;
                            west = Math.min(west, lng);
                            south = Math.min(south, lat);
                            east = Math.max(east, lng);
                            north = Math.max(north, lat);
                        });
                    } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiLineString') {
                        feature.geometry.coordinates.forEach(ring => {
                            ring.forEach(coord => {
                                const [lng, lat] = coord;
                                west = Math.min(west, lng);
                                south = Math.min(south, lat);
                                east = Math.max(east, lng);
                                north = Math.max(north, lat);
                            });
                        });
                    }
                }
            });
            
            // Only return bounds if we found coordinates
            if (west <= east && south <= north) {
                return [[west, south], [east, north]];
            }
            
            return null;
        }

        // Handle primary file upload
        document.getElementById('primary-file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            const startTime = performance.now();
            
            reader.onload = function(e) {
                try {
                    // Parse the GeoJSON
                    const geojson = JSON.parse(e.target.result);
                    const endTime = performance.now();
                    const loadTime = ((endTime - startTime) / 1000).toFixed(2);
                    
                    // Display file info
                    document.getElementById('file-info').textContent = `Loaded: ${file.name}`;
                    document.getElementById('feature-count').textContent = geojson.features ? geojson.features.length : 'N/A';
                    document.getElementById('visible-count').textContent = geojson.features ? geojson.features.length : 'N/A';
                    document.getElementById('load-time').textContent = `${loadTime}s`;
                    
                    // Add to map as primary dataset
                    addDatasetToMap(geojson, file.name);
                    
                } catch (error) {
                    alert(`Error loading GeoJSON: ${error.message}`);
                }
            };
            
            reader.readAsText(file);
        });
        
        // Handle additional file upload
        document.getElementById('additional-file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    // Parse the GeoJSON
                    const geojson = JSON.parse(e.target.result);
                    
                    // Add to map as additional dataset
                    addAdditionalDatasetToMap(geojson, file.name);
                    
                    // Update status
                    document.getElementById('status-info').textContent = `Added additional layer: ${file.name}`;
                    
                } catch (error) {
                    alert(`Error loading additional GeoJSON: ${error.message}`);
                }
            };
            
            reader.readAsText(file);
        });
        
        function addDatasetToMap(geojson, name) {
            // Remove existing datasets if any
            datasets.forEach(dataset => {
                if (map.getLayer(`${dataset.layerId}-hit`)) {
                    map.removeLayer(`${dataset.layerId}-hit`);
                }
                if (map.getLayer(dataset.layerId)) {
                    map.removeLayer(dataset.layerId);
                }
                if (map.getSource(dataset.sourceId)) {
                    map.removeSource(dataset.sourceId);
                }
            });
            
            datasets.length = 0; // Clear the array
            
            const id = `dataset-primary`;
            const sourceId = `source-${id}`;
            const layerId = `layer-${id}`;
            
            // Fix the geojson if it's using the wrong coordinate system
            const fixedGeojson = checkAndFixGeojson(geojson);
            
            // Store original data for filtering
            const originalData = JSON.parse(JSON.stringify(fixedGeojson));
            
            signDataGlobal = JSON.parse(JSON.stringify(geojson)); // Deep copy to avoid modification issues

            // Add the source
            map.addSource(sourceId, {
                type: 'geojson',
                data: fixedGeojson
            });
            
            // Determine the geometry type
            const geometryType = fixedGeojson.features && fixedGeojson.features.length > 0 
                ? fixedGeojson.features[0].geometry.type 
                : 'Point';
            
            if (geometryType.includes('Point')) {
                // Process features to assign colors to sign prefixes (keep for compatibility)
                processSignColors(fixedGeojson.features);
                
                // Update the sign features with colors for rendering
                fixedGeojson.features.forEach(feature => {
                    if (feature.properties.regulation_type) {
                        // Still extract and store the prefix for other code that needs it
                        const prefix = getSignPrefix(feature.properties.regulation_type);
                        feature.properties.signPrefix = prefix;
                        
                        // Use the direct regulation type to color mapping instead of prefix-based coloring
                        feature.properties.signColor = getColorForRegulationType(feature.properties.regulation_type);
                    }
                });
                
                // Update the source data with the modified features
                map.getSource(sourceId).setData(fixedGeojson);

                // Add visible circle layer with fixed colors from properties
                map.addLayer({
                    id: layerId,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': [
                            'case',
                            ['has', 'signColor'],
                            ['get', 'signColor'],
                            '#cccccc' // Default color if no signColor property
                        ],
                        'circle-opacity': 1,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#000'
                    }
                });
                
                // Add a larger invisible layer for better hit detection
                map.addLayer({
                    id: `${layerId}-hit`,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#000',
                        'circle-opacity': 0
                    }
                });
                
                // Update the legend
                updateLegend();
            } else if (geometryType.includes('Line')) {
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#3887be',
                        'line-width': 2
                    }
                });
            } else {
                map.addLayer({
                    id: layerId,
                    type: 'fill',
                    source: sourceId,
                    paint: {
                        'fill-color': '#3887be',
                        'fill-opacity': 0.5,
                        'fill-outline-color': '#000'
                    }
                });
            }
            
            // Set up popups for features
            if (geometryType.includes('Point')) {
                [layerId, `${layerId}-hit`].forEach(id => {
                    map.on('click', id, function(e) {
                        // Get the clicked feature
                        const feature = e.features[0];
                        const props = feature.properties;
                        
                        // Close any existing popup
                        if (currentPopup) {
                            currentPopup.remove();
                        }
                        
                        // Create a new popup
                        const popup = new mapboxgl.Popup({
                            closeButton: true,
                            closeOnClick: true,
                            maxWidth: '300px'
                        });
                        
                        // Store reference to the popup
                        currentPopup = popup;
                    
                        // Build popup content
                        let content = `<div style="font-family: sans-serif;">`;
                        content += `<h3 style="margin-top: 0;">Sign Details</h3>`;
                        
                        // Add requested fields
                        if (props.mutcd_code_field) {
                            const signColor = props.signColor || '#666';
                            content += `<p><strong>Code:</strong> <span style="color: ${signColor}; font-weight: bold;">${props.mutcd_code_field}</span></p>`;
                        }
                        
                        if (props.directionof_sign_arrow_field) {
                            content += `<p><strong>Direction:</strong> ${props.directionof_sign_arrow_field}</p>`;
                        }
                        
                        if (props.special_sign_description_field) {
                            content += `<p><strong>Description:</strong> ${props.special_sign_description_field}</p>`;
                        }
                        
                        // Add additional fields
                        if (props.asset_status_field) {
                            content += `<p><strong>Status:</strong> ${props.asset_status_field}</p>`;
                        }
                        
                        if (props.sign_orientation_field) {
                            content += `<p><strong>Orientation:</strong> ${props.sign_orientation_field}</p>`;
                        }
                        
                        if (props.cartegraph_id) {
                            content += `<p><strong>ID:</strong> ${props.cartegraph_id}</p>`;
                        }
                        
                        // Add address info if available
                        let addressStr = '';
                        if (props.address_number_field) addressStr += props.address_number_field + ' ';
                        if (props.street_field) addressStr += props.street_field;
                        
                        if (addressStr.trim()) {
                            content += `<p><strong>Address:</strong> ${addressStr}</p>`;
                        }
                        
                        if (props.city_field) {
                            content += `<p><strong>City:</strong> ${props.city_field}</p>`;
                        }
                        
                        // Add image thumbnail if available
                        if (props.attachment_public_url) {
                            content += `<p><strong>Image:</strong><br>
                                <a href="${props.attachment_public_url}" target="_blank">
                                    <img src="${props.attachment_public_url}" 
                                        style="max-width: 100%; max-height: 150px; margin-top: 5px; border: 1px solid #ccc;"
                                        alt="Sign photo">
                                </a>
                            </p>`;
                        }
                        
                        content += `</div>`;
                        
                        // Set popup content and position
                        popup.setLngLat(e.lngLat)
                            .setHTML(content)
                            .addTo(map);
                    });
                    
                    // Change cursor to pointer when hovering over a sign
                    map.on('mouseenter', id, function() {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    // Change cursor back when leaving a sign
                    map.on('mouseleave', id, function() {
                        map.getCanvas().style.cursor = 'grab';
                    });
                });
            }
            
            // Add to datasets array with original data for filtering
            datasets.push({
                id,
                sourceId,
                layerId,
                name,
                visible: true,
                originalData
            });
            
            // Update layer controls
            updateLayerControls();
            
            // Fit map to the data bounds
            const bounds = getBounds(fixedGeojson);
            if (bounds) {
                map.fitBounds(bounds, { padding: 50 });
            }

            // Apply sign type filter based on active prefixes
            applySignTypeFilter();
        }
        
        function addAdditionalDatasetToMap(geojson, name) {
            const id = `additional-${additionalDatasets.length}`;
            const sourceId = `source-${id}`;
            const layerId = `layer-${id}`;
            
            // Fix the geojson if it's using the wrong coordinate system
            const fixedGeojson = checkAndFixGeojson(geojson);
            
            // Store original data for future reference
            const originalData = JSON.parse(JSON.stringify(fixedGeojson));
            
            // Add the source
            map.addSource(sourceId, {
                type: 'geojson',
                data: fixedGeojson
            });
            
            // Determine the geometry type
            const geometryType = fixedGeojson.features && fixedGeojson.features.length > 0 
                ? fixedGeojson.features[0].geometry.type 
                : 'Point';
            
            // For LineString geometry, add individual feature IDs and colors
            let segmentfColors = {};
            
            // In your addAdditionalDatasetToMap function, replace the complex code with this:
            if (geometryType.includes('Line')) {
                // Only proceed with color matching if we have sign data available
                if (signDataGlobal && signDataGlobal.features && signDataGlobal.features.length > 0) {
                    fixedGeojson.features.forEach((feature, i) => {
                        if (!feature.id) {
                            feature.id = `line-${id}-${i}`;
                        }
                        
                        // Get the endpoint of this line segment
                        const coords = feature.geometry.coordinates;
                        const endpoint = coords[0]; // Using first point
                        
                        try {
                            // Find the nearest sign
                            const nearestSign = findNearestSign(endpoint, signDataGlobal.features);
                            
                            // Get regulation type from the nearest sign
                            if (nearestSign && nearestSign.properties && nearestSign.properties.regulation_type) {
                                // Update the feature properties with the nearest sign's regulation type
                                feature.properties.regulation_type = nearestSign.properties.regulation_type;
                                
                                // Set color based on the regulation type
                                const segmentColor = getColorForRegulationType(nearestSign.properties.regulation_type);
                                feature.properties.segmentColor = segmentColor;
                            } else {
                                // Fallback if nearest sign doesn't have regulation_type
                                feature.properties.segmentColor = getColorForRegulationType('Other');
                            }
                        } catch (error) {
                            console.warn("Error finding nearest sign:", error);
                            feature.properties.segmentColor = getColorForRegulationType('Other');
                        }
                    });
                }

                // Update the source with modified features
                map.getSource(sourceId).setData(fixedGeojson);
                
                // Add the layer with segment-specific coloring
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': ['get', 'segmentColor'],
                        'line-width': 2,
                        'line-opacity': 0.7
                    }
                });
                
                // Add a subtle outline layer to make segments more distinct
                map.addLayer({
                    id: `${layerId}-outline`,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#000000',
                        'line-width': 0.5,
                        'line-opacity': 0.3
                    }
                });
                
                // Set up click handlers for line segments
                map.on('click', layerId, function(e) {
                    // Get the clicked feature
                    const feature = e.features[0];
                    const props = feature.properties;
                    
                    // Close any existing popup
                    if (currentPopup) {
                        currentPopup.remove();
                    }
                    
                    // Create a new popup
                    const popup = new mapboxgl.Popup({
                        closeButton: true,
                        closeOnClick: true,
                        maxWidth: '300px'
                    });
                    
                    // Store reference to the popup
                    currentPopup = popup;
                
                    // Build popup content
                    let content = `<div style="font-family: sans-serif;">`;
                    content += `<h3 style="margin-top: 0;">Line Segment</h3>`;
                    
                    // Add ID
                    content += `<p><strong>ID:</strong> ${feature.id}</p>`;
                    
                    // Add any available properties
                    for (const [key, value] of Object.entries(props)) {
                        // Skip the color property we added
                        if (key === 'segmentColor') continue;
                        
                        // Skip array or object values to keep the popup clean
                        if (typeof value === 'object') continue;
                        
                        content += `<p><strong>${key}:</strong> ${value}</p>`;
                    }
                    
                    content += `</div>`;
                    
                    // Set popup content and position
                    popup.setLngLat(e.lngLat)
                        .setHTML(content)
                        .addTo(map);
                });
                
                // Change cursor when hovering over a line segment
                map.on('mouseenter', layerId, function() {
                    map.getCanvas().style.cursor = 'pointer';
                });
                
                map.on('mouseleave', layerId, function() {
                    map.getCanvas().style.cursor = 'grab';
                });
            } else if (geometryType.includes('Point')) {
                map.addLayer({
                    id: layerId,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': randomColor,
                        'circle-opacity': 0.8,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#000'
                    }
                });
            } else {
                map.addLayer({
                    id: layerId,
                    type: 'fill',
                    source: sourceId,
                    paint: {
                        'fill-color': randomColor,
                        'fill-opacity': 0.5,
                        'fill-outline-color': '#000'
                    }
                });
            }
            
            // Add to additionalDatasets array
            const datasetInfo = {
                id,
                sourceId,
                layerId,
                name,
                visible: true,
                color: randomColor,
                geometryType,
                originalData
            };
            
            // Add segment colors if applicable
            if (geometryType.includes('Line')) {
                datasetInfo.segmentColors = segmentColors;
                }

            additionalDatasets.push(datasetInfo);
            
            // Update additional layer controls
            updateAdditionalLayerControls();
            
            // If this is the first additional dataset, fit to its bounds
            if (additionalDatasets.length === 1) {
                const bounds = getBounds(fixedGeojson);
                if (bounds) {
                    map.fitBounds(bounds, { padding: 50 });
                }
            }
        }
        
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        
        function updateLayerControls() {
            // Function implementation can remain the same as the original
            // This function isn't used for the line segment coloring functionality
        }
        
        function updateAdditionalLayerControls() {
            const container = document.getElementById('additional-layer-items');
            container.innerHTML = '';
            
            if (additionalDatasets.length === 0) {
                container.innerHTML = '<p>No additional layers loaded</p>';
                return;
            }
            
            additionalDatasets.forEach(dataset => {
                const layerItem = document.createElement('div');
                layerItem.className = 'additional-layer-item';
                
                // Create checkbox for visibility
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = dataset.visible;
                checkbox.addEventListener('change', function() {
                    dataset.visible = this.checked;
                    const visibility = this.checked ? 'visible' : 'none';
                    map.setLayoutProperty(dataset.layerId, 'visibility', visibility);
                    
                    // Also update the legend visibility for line segments
                    if (dataset.geometryType.includes('Line')) {
                        const legendSection = document.getElementById('segment-legend');
                        if (legendSection) {
                            legendSection.style.display = this.checked ? 'block' : 'none';
                        }
                    }
                });
                
                // Create label
                const label = document.createElement('label');
                label.textContent = dataset.name;
                label.style.marginLeft = '5px';
                
                // Create color picker - only show for non-LineString geometry
                if (!dataset.geometryType.includes('Line')) {
                    const colorPicker = document.createElement('input');
                    colorPicker.type = 'color';
                    colorPicker.className = 'color-picker';
                    colorPicker.value = dataset.color;
                    colorPicker.addEventListener('change', function() {
                        const newColor = this.value;
                        dataset.color = newColor;
                        
                        // Update the layer color based on geometry type
                        if (dataset.geometryType.includes('Point')) {
                            map.setPaintProperty(dataset.layerId, 'circle-color', newColor);
                        } else {
                            map.setPaintProperty(dataset.layerId, 'fill-color', newColor);
                        }
                    });
                    
                    layerItem.appendChild(colorPicker);
                } else {
                    // For LineString layers, add a small label indicating diverging colors
                    const colorInfo = document.createElement('span');
                    colorInfo.textContent = " (random colors)";
                    colorInfo.style.fontSize = "0.8em";
                    colorInfo.style.color = "#666";
                    
                    label.appendChild(colorInfo);
                }
                
                // Add elements to container
                layerItem.appendChild(checkbox);
                layerItem.appendChild(label);
                container.appendChild(layerItem);
            });
        }
        
        // Add navigation controls
        map.addControl(new mapboxgl.NavigationControl());
    </script>
</body>
</html>