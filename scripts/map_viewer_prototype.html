// Initialize window.activePrefixes
        window.activePrefixes = new Set();
        
        // Initialize the map<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapbox GeoJSON Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 1;
            max-width: 300px;
            font-family: sans-serif;
            max-height: 90vh;
            overflow-y: auto;
        }
        .file-input {
            display: none;
        }
        .file-upload-btn {
            display: inline-block;
            padding: 8px 12px;
            background: #3887be;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .additional-file-upload-btn {
            display: inline-block;
            padding: 8px 12px;
            background: #38be7d;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .layer-control {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .color-picker {
            margin-left: 10px;
            width: 20px;
            height: 20px;
            padding: 0;
            border: none;
        }
        .mapboxgl-popup-content {
            padding: 15px;
        }
        .instructions {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        /* Ensure the cursor changes appropriately */
        .mapboxgl-canvas-container.mapboxgl-interactive {
            cursor: grab;
        }
        .mapboxgl-canvas-container.mapboxgl-interactive:active {
            cursor: grabbing;
        }
        /* Add specific style for points */
        .point-hover {
            cursor: pointer !important;
        }
        /* Filtering section styles */
        .filter-section {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .filter-section input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            box-sizing: border-box;
        }
        .filter-section button {
            margin-top: 5px;
            padding: 5px 10px;
            background: #3887be;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .filter-section button:hover {
            background: #2b6b99;
        }
        /* Legend styles */
        .legend {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 50%;
        }
        /* Additional layers section styles */
        .additional-layers {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .additional-layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="control-panel">
        <h3>GeoJSON Viewer</h3>
        <label class="file-upload-btn" for="primary-file-input">
            Upload Primary GeoJSON
        </label>
        <input type="file" id="primary-file-input" class="file-input" accept=".geojson,.json">
        
        <label class="additional-file-upload-btn" for="additional-file-input">
            Upload Additional GeoJSON
        </label>
        <input type="file" id="additional-file-input" class="file-input" accept=".geojson,.json">
        
        <div id="file-info"></div>
        
        <!-- Legend Section with Toggle Functionality -->
        <div class="legend" id="legend" style="display: none;">
            <h4>Sign Type Legend</h4>
            <div id="legend-items"></div>
        </div>
        
        <!-- Primary Layer Controls -->
        <div id="layer-controls"></div>
        
        <!-- Additional Layers Section -->
        <div class="additional-layers" id="additional-layers">
            <h4>Additional Layers</h4>
            <div id="additional-layer-items"></div>
        </div>
        
        <div class="stats">
            <p>Features: <span id="feature-count">0</span></p>
            <p>Visible: <span id="visible-count">0</span></p>
            <p>Loaded in: <span id="load-time">N/A</span></p>
            <p>Status: <span id="status-info">N/A</span></p>
        </div>
        
        <div class="instructions">
            <p><small>Click on any sign to view details. Toggle sign types in the legend.</small></p>
        </div>
    </div>

    <script>
        // Replace with your Mapbox access token
        mapboxgl.accessToken = 'pk.eyJ1IjoiYm9zdG9uc2FtNjE3IiwiYSI6ImNtODNlbnBoNzFvaTcyd3FienphaXRma2oifQ.S8oVyPkHgza9vrUBu0nwjQ';
        
        // Initialize the map
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/light-v11',
            center: [-96, 37.8], // Center on US
            zoom: 3,
            cursor: 'grab' // Set default cursor to grab
        });
        
        // Track loaded datasets
        const datasets = [];
        
        // Track additional datasets
        const additionalDatasets = [];
        
        // Track current popup globally
        let currentPopup = null;
        
        // Track sign prefixes and their colors
        let signTypeColors = {};
        

        
        // Function to update additional layer controls
        function updateAdditionalLayerControls() {
            const container = document.getElementById('additional-layer-items');
            if (!container) return; // Safety check
            
            container.innerHTML = '';
            
            if (additionalDatasets.length === 0) {
                container.innerHTML = '<p>No additional layers loaded</p>';
                return;
            }
            
            additionalDatasets.forEach(dataset => {
                const layerItem = document.createElement('div');
                layerItem.className = 'additional-layer-item';
                
                // Create checkbox for visibility
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = dataset.visible;
                checkbox.addEventListener('change', function() {
                    dataset.visible = this.checked;
                    const visibility = this.checked ? 'visible' : 'none';
                    map.setLayoutProperty(dataset.layerId, 'visibility', visibility);
                });
                
                // Create label
                const label = document.createElement('label');
                label.textContent = dataset.name;
                label.style.marginLeft = '5px';
                
                // Create color picker
                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.className = 'color-picker';
                colorPicker.value = dataset.color;
                colorPicker.addEventListener('change', function() {
                    const newColor = this.value;
                    dataset.color = newColor;
                    
                    // Update the layer color based on geometry type
                    if (dataset.geometryType.includes('Point')) {
                        map.setPaintProperty(dataset.layerId, 'circle-color', newColor);
                    } else if (dataset.geometryType.includes('Line')) {
                        map.setPaintProperty(dataset.layerId, 'line-color', newColor);
                    } else {
                        map.setPaintProperty(dataset.layerId, 'fill-color', newColor);
                    }
                });
                
                // This section is now defined in the updateAdditionalLayerControls function at the top of the script
            });
        }
        
        // Initialize event listeners after map loads
        map.on('load', function() {
            // Set default cursor
            map.getCanvas().style.cursor = 'grab';
            
            // Update cursor when panning starts/ends
            map.on('mousedown', function() {
                map.getCanvas().style.cursor = 'grabbing';
            });
            
            map.on('mouseup', function() {
                map.getCanvas().style.cursor = 'grab';
            });
        });
        
        // Check and fix geojson if needed (convert coordinates to WGS84)
        function checkAndFixGeojson(geojson) {
            // Check if it's already in the right format
            if (!geojson.features || geojson.features.length === 0) return geojson;
            
            // Check first feature to see if it has lat/long properties
            const firstFeature = geojson.features[0];
            const hasLatLongProps = 'latitude' in firstFeature.properties && 'longitude' in firstFeature.properties;
            
            // Check if coordinates look like they might be in a projected system (not WGS84)
            const coords = firstFeature.geometry.coordinates;
            const isProjected = Array.isArray(coords) && 
                               ((coords.length === 2 && (Math.abs(coords[0]) > 180 || Math.abs(coords[1]) > 90)) ||
                                (coords.length === 3 && (Math.abs(coords[0]) > 180 || Math.abs(coords[1]) > 90)));
            
            // If the coordinates are projected and we have lat/long props, fix the coordinates
            if (isProjected && hasLatLongProps) {
                console.log("Fixing GeoJSON coordinates - converting from projected to WGS84");
                
                const fixedGeojson = {
                    type: "FeatureCollection",
                    features: geojson.features.map(feature => {
                        // Create a new feature with the same properties
                        const newFeature = {
                            type: "Feature",
                            properties: feature.properties,
                            geometry: {
                                type: "Point",
                                // Use the longitude and latitude properties for coordinates
                                coordinates: [
                                    parseFloat(feature.properties.longitude), 
                                    parseFloat(feature.properties.latitude)
                                ]
                            }
                        };
                        return newFeature;
                    })
                };
                return fixedGeojson;
            }
            
            return geojson;
        }
        
        // Get sign prefix from mutcd_code_field (in JavaScript, not in MapboxGL expression)
        function getSignPrefix(code) {
            if (!code) return null;
            
            // Find the position of the dash
            const dashIndex = code.indexOf('-');
            
            // If there's a dash, return everything before it
            if (dashIndex !== -1) {
                return code.substring(0, dashIndex);
            }
            
            // If no dash, return first 1-2 characters (letters)
            const match = code.match(/^[A-Za-z]{1,2}/);
            return match ? match[0] : null;
        }
        
        // Generate consistent color for a sign prefix
        function getColorForSignType(prefix) {
            if (!prefix) return '#cccccc'; // Default gray
            
            // If we've already assigned a color, use it
            if (signTypeColors[prefix]) {
                return signTypeColors[prefix];
            }
            
            // Otherwise, generate a color based on the prefix
            const prefixSum = prefix.split('').reduce((sum, char) => sum + char.charCodeAt(0), 0);
            const hue = (prefixSum * 137.5) % 360; // Generate a hue based on the characters
            const saturation = 70; // Fixed saturation for better visibility
            const lightness = 45; // Fixed lightness for better visibility
            
            // Create HSL color
            const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            
            // Store for future reference
            signTypeColors[prefix] = color;
            
            return color;
        }
        
        // Pre-process features to assign colors based on prefixes
        function processSignColors(features) {
            // Clear existing sign colors
            signTypeColors = {};
            
            // Process each feature
            features.forEach(feature => {
                if (feature.properties && feature.properties.mutcd_code_field) {
                    const mutcdCode = feature.properties.mutcd_code_field;
                    if (mutcdCode) {
                        const prefix = getSignPrefix(mutcdCode);
                        if (prefix) {
                            // This will store the color if it's new
                            getColorForSignType(prefix);
                        }
                    }
                }
            });
    
    return signTypeColors;
}

            // Update the legend with sign prefixes and colors with toggle functionality
            function updateLegend() {
                const legendContainer = document.getElementById('legend-items');
                if (!legendContainer) return; // Safety check
                
                legendContainer.innerHTML = '';
                
                // Show the legend section
                const legendSection = document.getElementById('legend');
                if (legendSection) {
                    legendSection.style.display = 'block';
                };
                
                // Sort prefixes alphabetically
                const sortedPrefixes = Object.keys(signTypeColors).sort();
                
                // Initialize active prefixes (all active by default)
                if (!window.activePrefixes) {
                    window.activePrefixes = new Set();
                }
                
                // Add all prefixes to active set by default
                sortedPrefixes.forEach(prefix => {
                    window.activePrefixes.add(prefix);
                });
                
                // Add each prefix to the legend with a checkbox
                sortedPrefixes.forEach(prefix => {
                    const color = signTypeColors[prefix];
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    // Create checkbox for toggling this sign type
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = window.activePrefixes.has(prefix);
                    checkbox.style.marginRight = '5px';
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            window.activePrefixes.add(prefix);
                        } else {
                            window.activePrefixes.delete(prefix);
                        }
                        
                        // Apply the filter to show/hide sign types
                        applySignTypeFilter();
                    });
                    
                    const colorSwatch = document.createElement('div');
                    colorSwatch.className = 'legend-color';
                    colorSwatch.style.backgroundColor = color;
                    
                    const prefixLabel = document.createElement('span');
                    prefixLabel.textContent = `${prefix}`;
                    
                    legendItem.appendChild(checkbox);
                    legendItem.appendChild(colorSwatch);
                    legendItem.appendChild(prefixLabel);
                    legendContainer.appendChild(legendItem);
                });
            }
        
            function applySignTypeFilter() {
                // Only apply to primary dataset with point geometry
                datasets.forEach(dataset => {
                    if (!dataset.originalData || !dataset.originalData.features) return;
                    
                    // Create a filtered copy of the dataset
                    const filteredData = {
                        type: 'FeatureCollection',
                        features: dataset.originalData.features.filter(feature => {
                            // If feature has a mutcd_code_field property
                            if (feature.properties.mutcd_code_field) {
                                const prefix = getSignPrefix(feature.properties.mutcd_code_field);
                                // Keep only if prefix is in the active set
                                return window.activePrefixes.has(prefix);
                            }
                            // Keep features without a prefix
                            return true;
                        }).map(feature => {
                            // Create a copy of the feature to avoid modifying the original
                            const featureCopy = JSON.parse(JSON.stringify(feature));
                            
                            // Make sure signColor property is set based on the sign prefix
                            if (featureCopy.properties.mutcd_code_field) {
                                const prefix = getSignPrefix(featureCopy.properties.mutcd_code_field);
                                featureCopy.properties.signColor = getColorForSignType(prefix);
                                featureCopy.properties.signPrefix = prefix;
                            }
                            
                            return featureCopy;
                        })
                    };
                    
                    // Update the map source with filtered data
                    if (map.getSource(dataset.sourceId)) {
                        map.getSource(dataset.sourceId).setData(filteredData);
                    }
                    
                    // Update visible feature count
                    document.getElementById('visible-count').textContent = filteredData.features.length;
                });
            }

        
        // Handle primary file upload
        document.getElementById('primary-file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            const startTime = performance.now();
            
            reader.onload = function(e) {
                try {
                    // Parse the GeoJSON
                    const geojson = JSON.parse(e.target.result);
                    const endTime = performance.now();
                    const loadTime = ((endTime - startTime) / 1000).toFixed(2);
                    
                    // Display file info
                    document.getElementById('file-info').textContent = `Loaded: ${file.name}`;
                    document.getElementById('feature-count').textContent = geojson.features ? geojson.features.length : 'N/A';
                    document.getElementById('visible-count').textContent = geojson.features ? geojson.features.length : 'N/A';
                    document.getElementById('load-time').textContent = `${loadTime}s`;
                    
                    // Update the document reference to make sure it exists
                    if (document.getElementById('filter-section')) {
                        document.getElementById('filter-section').style.display = 'none';
                    }
                    
                    // Add to map as primary dataset
                    addDatasetToMap(geojson, file.name);
                    
                } catch (error) {
                    alert(`Error loading GeoJSON: ${error.message}`);
                }
            };
            
            reader.readAsText(file);
        });
        
        // Handle additional file upload
        document.getElementById('additional-file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    // Parse the GeoJSON
                    const geojson = JSON.parse(e.target.result);
                    
                    // Add to map as additional dataset
                    addAdditionalDatasetToMap(geojson, file.name);
                    
                    // Update status
                    document.getElementById('status-info').textContent = `Added additional layer: ${file.name}`;
                    
                } catch (error) {
                    alert(`Error loading additional GeoJSON: ${error.message}`);
                }
            };
            
            reader.readAsText(file);
        });
        
        function addDatasetToMap(geojson, name) {
            // Remove existing datasets if any
            datasets.forEach(dataset => {
                if (map.getLayer(`${dataset.layerId}-hit`)) {
                    map.removeLayer(`${dataset.layerId}-hit`);
                }
                if (map.getLayer(dataset.layerId)) {
                    map.removeLayer(dataset.layerId);
                }
                if (map.getSource(dataset.sourceId)) {
                    map.removeSource(dataset.sourceId);
                }
            });
            
            datasets.length = 0; // Clear the array
            
            const id = `dataset-primary`;
            const sourceId = `source-${id}`;
            const layerId = `layer-${id}`;
            
            // Fix the geojson if it's using the wrong coordinate system
            const fixedGeojson = checkAndFixGeojson(geojson);
            
            // Store original data for filtering
            const originalData = JSON.parse(JSON.stringify(fixedGeojson));
            
            // Add the source
            map.addSource(sourceId, {
                type: 'geojson',
                data: fixedGeojson
            });
            
            // Determine the geometry type
            const geometryType = fixedGeojson.features && fixedGeojson.features.length > 0 
                ? fixedGeojson.features[0].geometry.type 
                : 'Point';
            
            // For points, pre-process the sign prefixes and add colors
            if (geometryType.includes('Point')) {
                // Process features to assign colors to sign prefixes
                processSignColors(fixedGeojson.features);
                
                // Update the sign features with colors for rendering
                fixedGeojson.features.forEach(feature => {
                    if (feature.properties.mutcd_code_field) {
                        const prefix = getSignPrefix(feature.properties.mutcd_code_field);
                        // Store the color directly in the feature properties for easier access
                        feature.properties.signColor = getColorForSignType(prefix);
                        feature.properties.signPrefix = prefix;
                    }
                });
                
                // Update the source data with the modified features
                map.getSource(sourceId).setData(fixedGeojson);

                // Add visible circle layer with fixed colors from properties
                map.addLayer({
                    id: layerId,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': [
                            'case',
                            ['has', 'signColor'],
                            ['get', 'signColor'],
                            '#cccccc' // Default color if no signColor property
                        ],
                        'circle-opacity': 1,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#000'
                    }
                });
                
                // Add a larger invisible layer for better hit detection
                map.addLayer({
                    id: `${layerId}-hit`,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#000',
                        'circle-opacity': 0
                    }
                });
                
                // Update the legend
                updateLegend();
            } else if (geometryType.includes('Line')) {
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#3887be',
                        'line-width': 2
                    }
                });
            } else {
                map.addLayer({
                    id: layerId,
                    type: 'fill',
                    source: sourceId,
                    paint: {
                        'fill-color': '#3887be',
                        'fill-opacity': 0.5,
                        'fill-outline-color': '#000'
                    }
                });
            }
            
            // Set up popups for features
            if (geometryType.includes('Point')) {
                [layerId, `${layerId}-hit`].forEach(id => {
                    map.on('click', id, function(e) {
                        // Get the clicked feature
                        const feature = e.features[0];
                        const props = feature.properties;
                        
                        // Close any existing popup
                        if (currentPopup) {
                            currentPopup.remove();
                        }
                        
                        // Create a new popup
                        const popup = new mapboxgl.Popup({
                            closeButton: true,
                            closeOnClick: true,
                            maxWidth: '300px'
                        });
                        
                        // Store reference to the popup
                        currentPopup = popup;
                    
                        // Build popup content
                        let content = `<div style="font-family: sans-serif;">`;
                        content += `<h3 style="margin-top: 0;">Sign Details</h3>`;
                        
                        // Add requested fields
                        if (props.mutcd_code_field) {
                            const signColor = props.signColor || '#666';
                            content += `<p><strong>Code:</strong> <span style="color: ${signColor}; font-weight: bold;">${props.mutcd_code_field}</span></p>`;
                        }
                        
                        if (props.directionof_sign_arrow_field) {
                            content += `<p><strong>Direction:</strong> ${props.directionof_sign_arrow_field}</p>`;
                        }
                        
                        if (props.special_sign_description_field) {
                            content += `<p><strong>Description:</strong> ${props.special_sign_description_field}</p>`;
                        }
                        
                        // Add additional fields
                        if (props.asset_status_field) {
                            content += `<p><strong>Status:</strong> ${props.asset_status_field}</p>`;
                        }
                        
                        if (props.sign_orientation_field) {
                            content += `<p><strong>Orientation:</strong> ${props.sign_orientation_field}</p>`;
                        }
                        
                        if (props.cartegraph_id) {
                            content += `<p><strong>ID:</strong> ${props.cartegraph_id}</p>`;
                        }
                        
                        // Add address info if available
                        let addressStr = '';
                        if (props.address_number_field) addressStr += props.address_number_field + ' ';
                        if (props.street_field) addressStr += props.street_field;
                        
                        if (addressStr.trim()) {
                            content += `<p><strong>Address:</strong> ${addressStr}</p>`;
                        }
                        
                        if (props.city_field) {
                            content += `<p><strong>City:</strong> ${props.city_field}</p>`;
                        }
                        
                        // Add image thumbnail if available
                        if (props.attachment_public_url) {
                            content += `<p><strong>Image:</strong><br>
                                <a href="${props.attachment_public_url}" target="_blank">
                                    <img src="${props.attachment_public_url}" 
                                        style="max-width: 100%; max-height: 150px; margin-top: 5px; border: 1px solid #ccc;"
                                        alt="Sign photo">
                                </a>
                            </p>`;
                        }
                        
                        content += `</div>`;
                        
                        // Set popup content and position
                        popup.setLngLat(e.lngLat)
                            .setHTML(content)
                            .addTo(map);
                    });
                    
                    // Change cursor to pointer when hovering over a sign
                    map.on('mouseenter', id, function() {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    // Change cursor back when leaving a sign
                    map.on('mouseleave', id, function() {
                        map.getCanvas().style.cursor = 'grab';
                    });
                });
            }
            
            // Add to datasets array with original data for filtering
            datasets.push({
                id,
                sourceId,
                layerId,
                name,
                visible: true,
                originalData
            });
            
            // Update layer controls
            updateLayerControls();
            
            // Fit map to the data bounds
            const bounds = getBounds(fixedGeojson);
            if (bounds) {
                map.fitBounds(bounds, { padding: 50 });
            }

            // Apply sign type filter based on active prefixes
            applySignTypeFilter();
        }
        
        function addAdditionalDatasetToMap(geojson, name) {
            const id = `additional-${additionalDatasets.length}`;
            const sourceId = `source-${id}`;
            const layerId = `layer-${id}`;
            
            // Fix the geojson if it's using the wrong coordinate system
            const fixedGeojson = checkAndFixGeojson(geojson);
            
            // Generate a random color for this additional layer
            const randomColor = getRandomColor();
            
            // Add the source
            map.addSource(sourceId, {
                type: 'geojson',
                data: fixedGeojson
            });
            
            // Determine the geometry type
            const geometryType = fixedGeojson.features && fixedGeojson.features.length > 0 
                ? fixedGeojson.features[0].geometry.type 
                : 'Point';
            
            // Add layer based on geometry type
            if (geometryType.includes('Point')) {
                map.addLayer({
                    id: layerId,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': randomColor,
                        'circle-opacity': 0.8,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#000'
                    }
                });
            } else if (geometryType.includes('Line')) {
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': randomColor,
                        'line-width': 2
                    }
                });
            } else {
                map.addLayer({
                    id: layerId,
                    type: 'fill',
                    source: sourceId,
                    paint: {
                        'fill-color': randomColor,
                        'fill-opacity': 0.5,
                        'fill-outline-color': '#000'
                    }
                });
            }
            
            // Add to additionalDatasets array
            additionalDatasets.push({
                id,
                sourceId,
                layerId,
                name,
                visible: true,
                color: randomColor,
                geometryType
            });
            
            // Update additional layer controls
            updateAdditionalLayerControls();
            
            // If this is the first additional dataset, fit to its bounds
            if (additionalDatasets.length === 1) {
                const bounds = getBounds(fixedGeojson);
                if (bounds) {
                    map.fitBounds(bounds, { padding: 50 });
                }
            }
        }
        
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        
        function updateAdditionalLayerControls() {
            const container = document.getElementById('additional-layer-items');
            container.innerHTML = '';
            
            if (additionalDatasets.length === 0) {
                container.innerHTML = '<p>No additional layers loaded</p>';
                return;
            }
            
            additionalDatasets.forEach(dataset => {
                const layerItem = document.createElement('div');
                layerItem.className = 'additional-layer-item';
                
                // Create checkbox for visibility
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = dataset.visible;
                checkbox.addEventListener('change', function() {
                    dataset.visible = this.checked;
                    const visibility = this.checked ? 'visible' : 'none';
                    map.setLayoutProperty(dataset.layerId, 'visibility', visibility);
                });
                
                // Create label
                const label = document.createElement('label');
                label.textContent = dataset.name;
                label.style.marginLeft = '5px';
                
                // Create color picker
                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.className = 'color-picker';
                colorPicker.value = dataset.color;
                colorPicker.addEventListener('change', function() {
                    const newColor = this.value;
                    dataset.color = newColor;
                    
                    // Update the layer color based on geometry type
                    if (dataset.geometryType.includes('Point')) {
                        map.setPaintProperty(dataset.layerId, 'circle-color', newColor);
                    } else if (dataset.geometryType.includes('Line')) {
                        map.setPaintProperty(dataset.layerId, 'line-color', newColor);
                    } else {
                        map.setPaintProperty(dataset.layerId, 'fill-color', newColor);
                    }
                });
                
                // Add elements to container
                layerItem.appendChild(checkbox);
                layerItem.appendChild(label);
                layerItem.appendChild(colorPicker);
                container.appendChild(layerItem);
                });
        }
        
        // Add navigation controls
        map.addControl(new mapboxgl.NavigationControl());
    </script>
</body>
</html>